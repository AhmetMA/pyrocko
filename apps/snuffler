#!/usr/bin/env python

'''Effective MiniSEED trace viewer.'''

# Copyright (c) 2009, Sebastian Heimann <sebastian.heimann@zmaw.de>
#
# This file is part of snuffler. For licensing information please see the file 
# COPYING which is included with snuffler.

import os, sys, signal, logging, time
import numpy as num
from optparse import OptionParser

import pyrocko.pile
import pyrocko.util
import pyrocko.pile_viewer
import pyrocko.ipc

from PyQt4.QtCore import *
from PyQt4.QtGui import *

class SnufflerServer(pyrocko.ipc.RPCServer):
    
    def __init__(self, pile):
        RPCServer.__init__(self)
        self.pile = pile
        self.expose('add_trace')
        self.mutex = QMutex()
        self.queue_up = []
        self.queue_down = []

    def call(self, methodname, args, kwargs):
        if methodname in self.exposed:
            self.mutex.lock()
            self.queue_up.append((methodname, args, kwargs))
            self.mutex.unlock()
            
            self.mutex.lock()
            items = self.queue_down[0]
            self.queue_down[0:0] = []
            self.mutex.unlock()
            return getattr(self, methodname)(*args, **kwargs)


class ServerThread(QThread):
    def __init__(self, pile):
        QThread.__init__(self)
        self.server = SnufflerServer(pile)
    
    def run(self):
        self.server.run()
      
class ProgressiveLoader(QThread):
    
    def __init__(self, loader):
        QThread.__init__(self)
        self._loader = loader
        self._mutex = QMutex()
        self._queue = []
        self._done = False
        
    def run(self):
        for tfile in self._loader:
            self._mutex.lock()
            self._queue.append(tfile)
            self._mutex.unlock()
        
        self._mutex.lock()
        self._done = True
        self._mutex.unlock()
    
    def poll(self):
        self._mutex.lock()
        tfiles = self._queue[:]
        self._queue[:] = []
        self._mutex.unlock()
        return tfiles
    
    def done(self):
        self._mutex.lock()
        done = self._done
        self._mutex.unlock()
        return done

    def __iter__(self):
        while True:
            tfiles = self.poll()
            if not tfiles:
                if self.done():
                    return
            yield tfiles
     
     
class MySnuffler(QApplication):
    
    def __init__(self, *args):
        apply(QApplication.__init__, (self,) + args)
        
        self._dockwidgets = []
        
        parser = OptionParser()
        parser.add_option('--pattern', dest='pattern')
        parser.add_option('--ntracks', dest='ntracks', default=24)
        parser.add_option('--format', dest='format', default='from_extension', 
                          choices=('mseed', 'sac', 'kan', 'segy', 'from_extension', 'try'))
        parser.add_option('--debug', dest='debug', action='store_true', default=False)
        parser.add_option('--opengl', dest='opengl', action='store_true', default=False)
        parser.add_option('--server', dest='server', action='store_true', default=False)
        parser.add_option('--progressive', dest='progressive', action='store_true', default=False)
        parser.add_option('--force-cache', dest='force_cache', action='store_true', default=False)
        
        options, args = parser.parse_args(list(args[0][1:]))
        
        if options.debug:
            pyrocko.util.setup_logging('snuffler', 'debug')
        else:
            pyrocko.util.setup_logging('snuffler', 'warning')
        
        filenames = pyrocko.util.select_files( args, regex=options.pattern )
        cachedirname = '/tmp/snuffle_cache_%s' % os.environ['USER']
        if options.pattern and not options.force_cache:
            cache = None
        else:
            cache = pyrocko.pile.get_cache(cachedirname)
            
        pile = pyrocko.pile.Pile()
        
        if not options.progressive:
            pile.load_files( sorted(filenames), 
                        cache=cache, 
                        filename_attributes=options.pattern,
                        fileformat=options.format )
        else:
            l = pyrocko.pile.loader(sorted(filenames), 
                        fileformat=options.format, 
                        cache=cache, 
                        filename_attributes=options.pattern)
                
            self._loader = ProgressiveLoader(l)
            
        if options.server:
            self.pile_server = ServerThread(pile)
        
        self.win = QMainWindow()
        self.win.setWindowTitle( "Snuffler" )        

        self.pile_viewer = pyrocko.pile_viewer.PileViewer(
            pile, ntracks_shown_max=options.ntracks, use_opengl=options.opengl, add_panel_hook=self.add_panel)
        
        self.win.setCentralWidget( self.pile_viewer )
        
        self.add_panel('Main Controls', self.pile_viewer.controls())
                
        self.win.show()

        sb = self.win.statusBar()
        sb.clearMessage()
        sb.showMessage('Welcome to Snuffler! Click and drag to zoom and pan. Doubleclick to pick. Right-click for Menu. <space> to step forward. <b> to step backward. <q> to close.')

        self.connect(self, SIGNAL("lastWindowClosed()"), self.myquit)
        signal.signal(signal.SIGINT, self.myquit)
        
        if options.progressive:
            self._loader.start()
            self._loader_iterator = iter(self._loader)
            self._timer = QTimer( self )
            self.connect( self._timer, SIGNAL("timeout()"), self.periodical ) 
            self._timer.setInterval(500)
            self._timer.start()
    
    
    def periodical(self):
        try:
            files = self._loader_iterator.next()
            p = self.pile_viewer.get_pile()
            p.add_files(files)
            self.pile_viewer.update_contents()
                        
        except StopIteration:
            self._timer.stop()
            
       
    def add_panel(self, name, panel):
        dockwidget = QDockWidget(name)
        dockwidget.setWidget(panel)
        self.win.addDockWidget(Qt.BottomDockWidgetArea, dockwidget)
        
        if self._dockwidgets:
            self.win.tabifyDockWidget(self._dockwidgets[-1], dockwidget)
        
        self._dockwidgets.append(dockwidget)
        dockwidget.raise_()
        
        def delete_panel():
            self.win.removeDockWidget(dockwidget)
            self._dockwidgets.remove(dockwidget)
        
        return delete_panel
        
    def myquit(self, *args):
        self.quit()
    
def main(args):
    
    app = MySnuffler(args)
    app.exec_()
    
    if pyrocko.pile_viewer.Global.sacflag: pyrocko.pile_viewer.sac_exec()
    sys.exit()

if __name__=="__main__":
    main(sys.argv)
