#!/usr/bin/env python

'''Effective seismological trace viewer.'''

import os, sys, signal, logging, time, re, struct, base64, zlib
import numpy as num
import cPickle as pickle
from optparse import OptionParser

import pyrocko.pile, pyrocko.hamster_pile, pyrocko.slink, pyrocko.serial_hamster, \
       pyrocko.util, pyrocko.pile_viewer, pyrocko.ipc, pyrocko.model, pyrocko.config

from pyrocko.forked import Forked

from PyQt4.QtCore import *
from PyQt4.QtGui import *
from PyQt4.QtNetwork import *

logger = logging.getLogger('pyrocko.snuffler')

class AcquisitionThread(QThread):
    def __init__(self, post_process_sleep=0.0):
        QThread.__init__(self)
        self.mutex = QMutex()
        self.queue = []
        self.post_process_sleep = post_process_sleep
        self._sun_is_shining = True
    
    def run(self):
        while True:
            try:
                self.acquisition_start()
                while self._sun_is_shining:
                    t0 = time.time()
                    self.process()
                    t1 = time.time()
                    if self.post_process_sleep != 0.0:
                        time.sleep(max(0, self.post_process_sleep-(t1-t0)))
            
                self.acquisition_stop()
                break
            
            except (pyrocko.serial_hamster.SerialHamsterError, pyrocko.slink.SlowSlinkError), e:
                logger.error(str(e))
                logger.error('Acquistion terminated, restart in 5 s')
                self.acquisition_stop()
                time.sleep(5)
                if not self._sun_is_shining:
                    break
            
    def stop(self):
        self._sun_is_shining = False

        logger.debug("Waiting for thread to terminate...")
        self.wait()
        logger.debug("Thread has terminated.")
 
    def got_trace(self, tr):
        self.mutex.lock()
        self.queue.append(tr)
        self.mutex.unlock()
    
    def poll(self):
        self.mutex.lock()
        items = self.queue[:]
        self.queue[:] = []
        self.mutex.unlock()
        return items

class SlinkAcquisition(pyrocko.slink.SlowSlink, AcquisitionThread):
    def __init__(self, *args, **kwargs):
        pyrocko.slink.SlowSlink.__init__(self, *args, **kwargs)
        AcquisitionThread.__init__(self)

    def got_trace(self, tr):
        AcquisitionThread.got_trace(self,tr)

class CamAcquisition(pyrocko.serial_hamster.CamSerialHamster, AcquisitionThread):
    def __init__(self, *args, **kwargs):
        pyrocko.serial_hamster.CamSerialHamster.__init__(self, *args, **kwargs)
        AcquisitionThread.__init__(self, post_process_sleep=0.1)

    def got_trace(self, tr):
        AcquisitionThread.got_trace(self,tr)

class USBHB628Acquisition(pyrocko.serial_hamster.USBHB628Hamster, AcquisitionThread):
    def __init__(self, deltat=0.02, *args, **kwargs):
        pyrocko.serial_hamster.USBHB628Hamster.__init__(self, deltat=deltat, *args, **kwargs)
        AcquisitionThread.__init__(self)

    def got_trace(self, tr):
        AcquisitionThread.got_trace(self,tr)


class SchoolSeismometerAcquisition(pyrocko.serial_hamster.SerialHamster, AcquisitionThread):
    def __init__(self, *args, **kwargs):
        pyrocko.serial_hamster.SerialHamster.__init__(self, *args, **kwargs)
        AcquisitionThread.__init__(self, post_process_sleep=0.1)

    def got_trace(self, tr):
        AcquisitionThread.got_trace(self,tr)

import asyncore, asynchat, socket, struct

class Channel(asynchat.async_chat):

    def __init__(self, sock=None, port=None, ticket=None):
        if sock is not None:
            asynchat.async_chat.__init__(self, sock)
        else:
            asynchat.async_chat.__init__(self)
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
            self.connect( ('', port) )

        self.ibuffer = []
        self.set_terminator(8)
        self.reading_size = True
        self.ticket = ticket
        self.compressor = zlib.compressobj()
        self.decompressor = zlib.decompressobj()


    def handle_connect(self):
        if self.ticket is not None:
            self.ship(self.ticket)

    def collect_incoming_data(self, data):
        self.ibuffer.append(data)

    def found_terminator(self):
        if self.reading_size:
            size = struct.unpack('>Q', ''.join(self.ibuffer))[0]
            self.set_terminator(size)
            self.reading_size = False
        else:
            data = ''.join(self.ibuffer)
            payload = pickle.loads(self.decompressor.decompress(data))
            if payload is None:
                self.close_when_done()
                self.set_terminator(None)
            else:
                self.handle_received(payload)
                self.set_terminator(8)
                self.reading_size = True
        
        self.ibuffer = []

    def ship(self, obj):
        data = self.compressor.compress(pickle.dumps(obj))
        data_end = self.compressor.flush(zlib.Z_FULL_FLUSH)
        sdata = struct.pack('>Q', len(data)+len(data_end))
        self.push(sdata)
        self.push(data)
        self.push(data_end)

    def handle_received(self, obj):
        pass

class Connection(QObject):
    def __init__(self, parent, sock):
        QObject.__init__(self, parent)
        self.socket = sock
        self.connect(sock, SIGNAL('readyRead()'), self.handle_read)
        self.connect(sock, SIGNAL('disconnected()'), self.handle_disconnected)
        self.nwanted = 8
        self.reading_size = True
        self.handler = None
        self.nbytes_received = 0
        self.nbytes_sent = 0
        self.compressor = zlib.compressobj()
        self.decompressor = zlib.decompressobj()

    def handle_read(self):
        while True:
            navail = self.socket.bytesAvailable()
            if navail < self.nwanted:
                return

            data = self.socket.read(self.nwanted)
            self.nbytes_received += len(data)
            if self.reading_size:
                self.nwanted = struct.unpack('>Q', data)[0]
                self.reading_size = False
            else:
                obj = pickle.loads(self.decompressor.decompress(data))
                if obj is None:
                    self.socket.disconnectFromHost()
                else:
                    self.handle_received(obj)
                self.nwanted = 8
                self.reading_size = True

    def handle_received(self, obj):
        self.emit(SIGNAL('received(PyQt_PyObject,PyQt_PyObject)'), self, obj)

    def ship(self, obj):
        data = self.compressor.compress(pickle.dumps(obj))
        data_end = self.compressor.flush(zlib.Z_FULL_FLUSH)
        self.socket.write(struct.pack('>Q', len(data)+len(data_end)))
        self.socket.write(data)
        self.socket.write(data_end)
        self.nbytes_sent += len(data)+len(data_end) + 8

    def handle_disconnected(self):
        self.emit(SIGNAL('disconnected(PyQt_PyObject)'), self)

    def close(self):
        self.socket.close()

class ConnectionHandler(QObject):
    def __init__(self, parent):
        QObject.__init__(self, parent)
        self.queue = []
        self.connection = None

    def connected(self):
        return self.connection == None

    def set_connection(self, connection):
        self.connection = connection
        self.connect(connection, SIGNAL('received(PyQt_PyObject,PyQt_PyObject)'), self._handle_received)
        self.connect(connection, SIGNAL('disconnected(PyQt_PyObject)'), self.handle_disconnected)
        for obj in self.queue:
            self.connection.ship(obj)
        self.queue = []

    def _handle_received(self, conn, obj):
        self.handle_received(obj)

    def handle_received(self, obj):
        pass

    def handle_disconnected(self):
        self.connection = None

    def ship(self, obj):
        if self.connection:
            self.connection.ship(obj)
        else:
            self.queue.append(obj)

class SimpleConnectionHandler(ConnectionHandler):
    def __init__(self, parent, **mapping):
        ConnectionHandler.__init__(self, parent)
        self.mapping = mapping

    def handle_received(self, obj):
        command = obj[0]
        args = obj[1:]
        self.mapping[command](*args)
     
class SnufflerTabs(QTabWidget):
    def __init__(self, parent):
        QTabWidget.__init__(self, parent)
        if hasattr(self, 'setTabsClosable'):
            self.setTabsClosable(True)
        self.connect(self, SIGNAL('tabCloseRequested(int)'), self.removeTab)
        if hasattr(self, 'setDocumentMode'):
            self.setDocumentMode(True)

    def hide_close_button_on_first_tab(self):
        tbar = self.tabBar()
        if hasattr(tbar ,'setTabButton'):
            tbar.setTabButton(0, QTabBar.LeftSide, None)
            tbar.setTabButton(0, QTabBar.RightSide, None)

    def append_tab(self, widget, name):
        widget.setParent(self)
        self.insertTab(self.count(), widget, name)
        self.setCurrentIndex(self.count()-1)

    def tabInserted(self, index):
        if index == 0:
            self.hide_close_button_on_first_tab()

        self.tabbar_visibility()

    def tabRemoved(self, index):
        self.tabbar_visibility()

    def tabbar_visibility(self):
        if self.count() <= 1:
            self.tabBar().hide()
        elif self.count() > 1:
            self.tabBar().show()
     
class MyMainWindow(QMainWindow):

    def __init__(self, app, *args):
        QMainWindow.__init__(self, *args)
        self.app = app

    def keyPressEvent(self, ev):
        self.app.pile_viewer.get_view().keyPressEvent(ev)


class MySnuffler(QApplication):
    
    def __init__(self, args, forker):
        QApplication.__init__(self, [])
        
        self.dockwidget_to_toggler = {}

        usage = '''usage: %prog [options] waveforms ...'''
        
        parser = OptionParser(usage=usage)
        parser.add_option('--format', dest='format', default='from_extension',
                choices=('mseed', 'sac', 'kan', 'segy', 'seisan', 'seisan_l', 'seisan_b', 'from_extension', 'try'),
                help='assume files are of given FORMAT [default: \'%default\']' )
        parser.add_option('--pattern', dest='pattern', metavar='REGEX',
                help='only include files whose paths match REGEX')
        parser.add_option('--stations', dest='station_fns', action='append', default=[], metavar='STATIONS',
                help='read station information from file STATIONS')
        parser.add_option('--event', '--events', dest='event_fns', action='append', default=[], metavar='EVENT',
                help='read event information from file EVENT')
        parser.add_option('--markers', dest='marker_fns', action='append', default=[], metavar='MARKERS',
                help='read marker information file MARKERS')
        parser.add_option('--follow', dest='follow', metavar='N',
                help='follow real time with a window of N seconds')
        parser.add_option('--progressive', dest='progressive', action='store_true', default=False,
                help='don\'t wait for file scanning to complete before opening the viewer')
        parser.add_option('--cache', dest='cache_dir', default='/tmp/pyrocko_0.2_cache_%s' % os.environ['USER'], metavar='DIR',
                help='use directory DIR to cache trace metadata (default=\'%default\')')
        parser.add_option('--force-cache', dest='force_cache', action='store_true', default=False,
                help='use the cache even when trace attribute spoofing is active (may have silly consequences)')
        parser.add_option('--ntracks', dest='ntracks', default=24, metavar='N',
                help='initially use N waveform tracks in viewer [default: %default]')
        parser.add_option('--opengl', dest='opengl', action='store_true', default=False,
                help='use OpenGL for drawing')
        parser.add_option('--debug', dest='debug', action='store_true', default=False,
                help='print debugging information to stderr')
        
        options, args = parser.parse_args(list(args[1:]))
        
        if options.debug:
            pyrocko.util.setup_logging('snuffler', 'debug')
        else:
            pyrocko.util.setup_logging('snuffler', 'warning')
       
        self._sources = []
        rargs = []

        self.commandline_dirfilenames = list(args)
        for arg in args:
            msl = re.match(r'seedlink://([a-zA-Z0-9.-]+)(:(\d+))?(/(.*))?', arg)
            mca = re.match(r'cam://([^:]+)', arg)
            mus = re.match(r'hb628://([^:?]+)(\?(\d+))?', arg)
            msc = re.match(r'school://([^:]+)', arg)
            if msl:
                host = msl.group(1)
                port = msl.group(3)
                if not port:
                    port = '18000'
                stream_patterns = msl.group(5).split(',')
                sl = SlinkAcquisition(host=host, port=port)
                try:
                    streams = sl.query_streams()
                except pyrocko.slink.SlowSlinkError, e:
                    logger.fatal(str(e))
                    sys.exit(1)

                streams = pyrocko.util.match_nslcs(stream_patterns, streams)
                for stream in streams:
                    sl.add_stream(*stream)
                    
                self._sources.append(sl)
            elif mca:
                port = mca.group(1)
                cam = CamAcquisition(port=port, deltat=0.0314504)
                self._sources.append(cam)
            elif mus:
                port = mus.group(1)
                if mus.group(3):
                    deltat = 1./float(mus.group(3))
                else:
                    deltat = 0.02
                hb628 = USBHB628Acquisition(port=port, deltat=deltat, buffersize=16, lookback=50)
                self._sources.append(hb628)
            elif msc:
                port = msc.group(1)
                sco = SchoolSeismometerAcquisition(port=port)
                self._sources.append(sco)
                
            else:
                rargs.append(arg)
        
        if self._sources:
            pile = pyrocko.hamster_pile.HamsterPile()        
            pile.set_fixation_length(60.*60.)
            #pile.set_save_path('test_snuffslink_traces')
        else:
            pile = pyrocko.pile.Pile()
        
        self._win = MyMainWindow(self)
        self._win.setWindowTitle( "Snuffler" )        

        self.pile_viewer = pyrocko.pile_viewer.PileViewer(
            pile, ntracks_shown_max=options.ntracks, use_opengl=options.opengl, panel_parent=self)
        
        for stations_fn in options.station_fns:
            stations = pyrocko.model.load_stations(stations_fn)
            self.pile_viewer.get_view().add_stations(stations)
        
        first = True
        for event_fn in options.event_fns:
            for ev in pyrocko.model.Event.load_catalog(event_fn):
                self.pile_viewer.get_view().add_event(ev)
                if first:
                    self.pile_viewer.get_view().set_origin(ev)
                    first = False

        for marker_fn in options.marker_fns:
            self.pile_viewer.get_view().add_markers(pyrocko.pile_viewer.Marker.load_markers(marker_fn))

        self._tabs = SnufflerTabs(self._win)
        self._win.setCentralWidget( self._tabs )
        self.add_tab('Main', self.pile_viewer)
        
        self.pile_viewer.setup_snufflings()

        self.add_panel('Main Controls', self.pile_viewer.controls(), visible=True)
        self._win.show()

        self.pile_viewer.get_view().setFocus(Qt.OtherFocusReason)

        sb = self._win.statusBar()
        sb.clearMessage()
        sb.showMessage('Welcome to Snuffler! Click and drag to zoom and pan. Doubleclick to pick. Right-click for Menu. <space> to step forward. <b> to step backward. <q> to close.')

        self.connect(self, SIGNAL("lastWindowClosed()"), self.myquit)
        signal.signal(signal.SIGINT, self.myquit)
            
        for source in self._sources:
            source.start()

        if self._sources:
            self._timer = QTimer( self )
            self.connect( self._timer, SIGNAL("timeout()"), self.periodical ) 
            self._timer.setInterval(500)
            self._timer.start()
            
        if options.follow:
            self.pile_viewer.get_view().follow(float(options.follow))
        
        self.connection_handlers = {}

        self.forker = forker
        self.start_server()
        self.start_loader()

        self.cachedirname = pyrocko.config.cache_dir
        if options.pattern and not options.force_cache:
            self.cachedirname = None

        if rargs:
            self.loader.ship(('load', rargs, self.cachedirname, options.pattern, options.format ))
   
    def start_server(self):
        self.connections = []
        s = QTcpServer(self)
        s.listen(QHostAddress.LocalHost)
        self.connect(s, SIGNAL('newConnection()'), self.handle_accept)
        self.server = s

    def start_loader(self):
        self.loader = SimpleConnectionHandler(self, add_files=self.add_files, update_progress=self.update_progress)
        ticket = os.urandom(32)
        self.forker.spawn('loader', self.server.serverPort(), ticket)
        self.connection_handlers[ticket] = self.loader

    def handle_accept(self):
        sock = self.server.nextPendingConnection()
        con = Connection(self, sock)
        self.connections.append(con)
        self.connect(con, SIGNAL('disconnected(PyQt_PyObject)'), self.handle_disconnected) 
        self.connect(con, SIGNAL('received(PyQt_PyObject,PyQt_PyObject)'), self.handle_received_ticket)

    def handle_disconnected(self, connection):
        self.connections.remove(connection)
        connection.close()
        del connection

    def handle_received_ticket(self, connection, object):
        if not isinstance(object, str):
            self.handle_disconnected(connection)

        ticket = object
        if ticket in self.connection_handlers:
            h = self.connection_handlers[ticket]
            self.disconnect(connection, SIGNAL('received(PyQt_PyObject,PyQt_PyObject)'), self.handle_received_ticket)
            h.set_connection(connection)
        else:
            self.handle_disconnected(connection)

    def add_files(self, files):
        p = self.pile_viewer.get_pile()
        p.add_files(files)
        self.pile_viewer.update_contents()

    def update_progress(self, task, percent):
        self.pile_viewer.progressbars.set_status(task, percent)
    
    def add_tab(self, name, widget):
        self._tabs.append_tab(widget, name)

    def periodical(self):
        p = self.pile_viewer.get_pile()
        update = False
          
        for source in self._sources:
            traces = source.poll()
            for tr in traces:
                p.insert_trace(tr)
            if traces:
                update = True
        
        if update:
            self.pile_viewer.update_contents()

    def event(self, e):
        if isinstance(e, QFileOpenEvent):
            fn = str(e.file())
            if fn in self.commandline_dirfilenames:
                # must filter these to not get duplicates
                self.commandline_dirfilenames.remove(fn)
            else:
                filenames = pyrocko.util.select_files([str(e.file())])

                p = self.pile_viewer.get_pile()
                cache = pyrocko.pile.get_cache(self.cachedirname)
                p.add_files(pyrocko.pile.loader(filenames, 
                                 fileformat='from_extension', 
                                 cache=cache,
                                 filename_attributes=None))
                self.pile_viewer.update_contents() 
            
            return True
        else:
            return QApplication.event(self, e)

    def dockwidgets(self):
        return [ w for w in self._win.findChildren(QDockWidget) if not w.isFloating() ]

    def get_panel_parent_widget(self):
        return self._win

    def add_panel(self, name, panel, visible=False, volatile=False):
        dws = self.dockwidgets()
        dockwidget = QDockWidget(name, self._win)
        dockwidget.setWidget(panel)
        panel.setParent(dockwidget)
        self._win.addDockWidget(Qt.BottomDockWidgetArea, dockwidget)

        if dws:
            self._win.tabifyDockWidget(dws[-1], dockwidget)
        
        self.toggle_panel(dockwidget, visible)

        mitem = QAction(name, None)
        
        def toggle_panel(checked):
            self.toggle_panel(dockwidget, True)

        self.connect( mitem, SIGNAL('triggered(bool)'), toggle_panel)
        
        if volatile:
            def visibility(visible):
                if not visible:
                    self.remove_panel(panel)

            self.connect( dockwidget, SIGNAL('visibilityChanged(bool)'), visibility)

        self.pile_viewer.get_view().add_panel_toggler(mitem)

        self.dockwidget_to_toggler[dockwidget] = mitem


    def toggle_panel(self, dockwidget, visible):
        dockwidget.setVisible(visible)
        if visible:
            dockwidget.setFocus()
            dockwidget.raise_()

    def remove_panel(self, panel):
        dockwidget = panel.parent()
        self._win.removeDockWidget(dockwidget)
        dockwidget.setParent(None)
        mitem = self.dockwidget_to_toggler[dockwidget]
        self.pile_viewer.get_view().remove_panel_toggler(mitem)
        
    def myquit(self, *args):
        for con in self.connections:
            con.ship(None)
        
        for source in self._sources:
            source.stop()
        
        p = self.pile_viewer.get_pile()
        if hasattr(p, 'fixate_all'):
            self.pile_viewer.get_pile().fixate_all()
        self.quit()

class FileLoader(Channel):
    def __init__(self, port, ticket):
        Channel.__init__(self, port=port, ticket=ticket)
        self.loaders = []
        self.tship_start = None
        self.tship_progress = None
        self.iloader = 0
    
    def handle_received(self, obj):
        if obj[0] == 'load':
            pathes, cachedirname, pattern, format = obj[1:]
            
            cache = None
            if cachedirname is not None:
                cache = pyrocko.pile.get_cache(cachedirname)

            filenames = pyrocko.util.select_files( pathes, regex=pattern )
            if filenames:
                self.iloader += 1
                iloader = self.iloader
                def upp(i,n):
                    return self.update_progress(iloader, i, n)

                self.loaders.append(pyrocko.pile.loader(sorted(filenames), 
                                    fileformat=format, 
                                    cache=cache, 
                                    filename_attributes=pattern, 
                                    show_progress=False,
                                    update_progress=upp ))

    def update_progress(self, iloader, i, n):
      
        percent = (i*100)/n
        tnow = time.time()
        if ((percent == 100 and self.tship_progress is not None) or
                (tnow > self.tship_start + 3. and 
                    self.tship_progress is not None and tnow - self.tship_progress > 0.05)):

            self.ship(('update_progress', 'scanning files %i' % iloader, percent))
            self.tship_progress = tnow

    def run(self):
        i =0
        self.tship_start = time.time()
        tship = self.tship_start
        queue = []
        while True:
            if self.loaders:
                timeout = 0.
            else:
                timeout = 10. 

            asyncore.loop(timeout=timeout, count=1)
            if not asyncore.socket_map:
                return

            if self.loaders:
                done = []
                for loader in self.loaders:
                    try:
                        queue.append( loader.next() )
                        tnow = time.time()
                        if tnow - self.tship_start > 3.0 and tnow - tship > 0.05:
                            self.ship(('add_files', queue))
                            tship = tnow
                            queue = []

                    except StopIteration:
                        done.append(loader)
                        if queue:
                            self.ship(('add_files', queue))
                            queue = []

                for loader in done:
                    self.loaders.remove(loader)

            i+=1

class Forker(Forked):

    subsystems = {
            'loader': FileLoader
    }

    def __init__(self):
        Forked.__init__(self)
        self.commands = ('spawn',)

    def spawn_(self, subsystem, *args):
        pid = os.fork()
        if pid == 0:

            cls = Forker.subsystems[subsystem]
            s = cls(*args)
            s.run()
            sys.exit()

def main(args):
    forker = Forker()    
    app = MySnuffler(args, forker)
    app.exec_()
    forker.close()

if __name__=="__main__":
    main(sys.argv)


