#!/usr/bin/env python

import os, sys, signal, logging, re, time, random, struct
import numpy as num
from optparse import OptionParser

import pyrocko.hamster_pile
import pyrocko.util
import pyrocko.pile_viewer
import pyrocko.slink
import pyrocko.serial_hamster

from PyQt4.QtCore import *
from PyQt4.QtGui import *

logger = logging.getLogger('pyrocko.slinksnuff')

class TestInput:
    def write(self, data):
        pass

    def flush(self):
        pass

    def read(self, n):
        return struct.pack( str(n)+'B', *[ random.randint(0,255) for i in xrange(n) ] )

class AcquisitionThread(QThread):
    def __init__(self, post_process_sleep=0.0):
        QThread.__init__(self)
        self.mutex = QMutex()
        self.queue = []
        self.post_process_sleep = post_process_sleep
        self._sun_is_shining = True
    
    def run(self):
        while True:
            try:
                self.acquisition_start()
                while self._sun_is_shining:
                    t0 = time.time()
                    self.process()
                    t1 = time.time()
                    if self.post_process_sleep != 0.0:
                        time.sleep(max(0, self.post_process_sleep-(t1-t0)))
            
                self.acquisition_stop()
                break
            
            except (pyrocko.serial_hamster.SerialHamsterError, pyrocko.slink.SlowSlinkError), e:
                logger.error(str(e))
                logger.error('Acquistion terminated, restart in 5 s')
                self.acquisition_stop()
                time.sleep(5)
                if not self._sun_is_shining:
                    break
            
    def stop(self):
        self._sun_is_shining = False

        logger.debug("Waiting for thread to terminate...")
        self.wait()
        logger.debug("Thread has terminated.")
 
    def got_trace(self, tr):
        self.mutex.lock()
        self.queue.append(tr)
        self.mutex.unlock()
    
    def poll(self):
        self.mutex.lock()
        items = self.queue[:]
        self.queue[:] = []
        self.mutex.unlock()
        return items

class SlinkAcquisition(pyrocko.slink.SlowSlink, AcquisitionThread):
    def __init__(self, *args, **kwargs):
        pyrocko.slink.SlowSlink.__init__(self, *args, **kwargs)
        AcquisitionThread.__init__(self)

    def got_trace(self, tr):
        AcquisitionThread.got_trace(self,tr)

class CamAcquisition(pyrocko.serial_hamster.CamSerialHamster, AcquisitionThread):
    def __init__(self, *args, **kwargs):
        pyrocko.serial_hamster.CamSerialHamster.__init__(self, *args, **kwargs)
        AcquisitionThread.__init__(self, post_process_sleep=0.1)

    def got_trace(self, tr):
        AcquisitionThread.got_trace(self,tr)

class USBHB628Acquisition(pyrocko.serial_hamster.USBHB628Hamster, AcquisitionThread):
    def __init__(self, deltat=0.02, *args, **kwargs):
        pyrocko.serial_hamster.USBHB628Hamster.__init__(self, deltat=deltat, *args, **kwargs)
        AcquisitionThread.__init__(self)

    def got_trace(self, tr):
        AcquisitionThread.got_trace(self,tr)


class SlinkSnuffler(QApplication):
    
    def __init__(self, *args):
        apply(QApplication.__init__, (self,) + args)
        
        parser = OptionParser()
        parser.add_option('--ntracks', dest='ntracks', default=24)
        parser.add_option('--debug', dest='debug', action='store_true', default=False)
        #parser.add_option('--seedlink', dest='seedlinkurl') #   seedlink://geofon.gfz-potsdam.de:18000/
        #parser.add_option('--streams', dest='streams', default='GE.WLF..BHZ')
        #parser.add_option('--host', dest='host', default='geofon.gfz-potsdam.de')
        #parser.add_option('--port', dest='port', default='18000')
        parser.add_option('--follow', dest='follow')
        parser.add_option('--opengl', dest='opengl', action='store_true', default=False)

        options, args = parser.parse_args(list(args[0][1:]))
        if len(args) == 0:
            args.append('seedlink://geofon.gfz-potsdam.de/GE.*.*.BHZ')

        if options.debug:
            pyrocko.util.setup_logging('snuffler', 'debug')
        else:
            pyrocko.util.setup_logging('snuffler', 'warning')
        
        if options.follow:
            self.follow_length = options.follow
        else:
            self.follow_length = None

        self.win = QMainWindow()
        self.win.setWindowTitle( "Snuffslink" )        
        self._dockwidgets = []
        
        self.pile = pyrocko.hamster_pile.HamsterPile()
        self.pile_viewer = pyrocko.pile_viewer.PileViewer(
                    self.pile, 
                    ntracks_shown_max=options.ntracks,
                    use_opengl=options.opengl, add_panel_hook=self.add_panel)
                    
        self.pile.set_fixation_length(60.*60.)
        #self.pile.set_save_path('test_snuffslink_traces')
        
        self.win.setCentralWidget( self.pile_viewer )
        self.add_panel('Main Controls', self.pile_viewer.controls())
        self.win.show()

        sb = self.win.statusBar()
        sb.clearMessage()
        sb.showMessage('Welcome to Snuffler! Click and drag to zoom and pan. Doubleclick to pick. Right-click for Menu. <space> to step forward. <b> to step backward. <q> to close.')

        self.connect(self, SIGNAL("lastWindowClosed()"), self.myquit)
        signal.signal(signal.SIGINT, self.myquit)
        
        self.sources = []
        for arg in args:
            msl = re.match(r'seedlink://([a-zA-Z0-9.-]+)(:(\d+))?(/(.*))?', arg)
            mca = re.match(r'cam://([^:]+)', arg)
            mus = re.match(r'hb628://([^:?]+)(\?(\d+))?', arg)
            if msl:
                host = msl.group(1)
                port = msl.group(3)
                if not port:
                    port = '18000'
                stream_patterns = msl.group(5).split(',')
                sl = SlinkAcquisition(host=host, port=port)
                try:
                    streams = sl.query_streams()
                except pyrocko.slink.SlowSlinkError, e:
                    logger.fatal(str(e))
                    sys.exit(1)

                streams = pyrocko.util.match_nslcs(stream_patterns, streams)
                for stream in streams:
                    sl.add_stream(*stream)
                    
                self.sources.append(sl)
            elif mca:
                port = mca.group(1)
                cam = CamAcquisition(port=port, deltat=0.0314504)
                self.sources.append(cam)
            elif mus:
                port = mus.group(1)
                if mus.group(3):
                    deltat = 1./float(mus.group(3))
                else:
                    deltat = 0.02
                hb628 = USBHB628Acquisition(port=port, deltat=deltat, buffersize=16, lookback=50)
                self.sources.append(hb628)

        self.timer = QTimer( self )
        self.connect( self.timer, SIGNAL("timeout()"), self.periodical ) 
        self.timer.setInterval(500)
        self.timer.start()
        
        if options.follow:
            self.pile_viewer.get_view().follow(float(options.follow))

        self.traces = {}
        self.traces_to_files = {}
        
        for source in self.sources:
            source.start()

    def add_panel(self, name, panel):
        dockwidget = QDockWidget(name)
        dockwidget.setWidget(panel)
        self.win.addDockWidget(Qt.BottomDockWidgetArea, dockwidget)
        
        if self._dockwidgets:
            self.win.tabifyDockWidget(self._dockwidgets[-1], dockwidget)
        
        self._dockwidgets.append(dockwidget)
        dockwidget.raise_()
        
        def delete_panel():
            self.win.removeDockWidget(dockwidget)
            self._dockwidgets.remove(dockwidget)
        
        return delete_panel
    
    def periodical(self):
        for source in self.sources:
            traces = source.poll()
            for tr in traces:
                self.pile.insert_trace(tr)

        self.pile_viewer.update_contents()

    def myquit(self, *args):
        self.pile.fixate_all()
        for source in self.sources:
            source.stop()
        self.quit()
    
def main(args):
    
    app = SlinkSnuffler(args)
    app.exec_()
    
    if pyrocko.pile_viewer.Global.sacflag: pyrocko.pile_viewer.sac_exec()
    sys.exit()

if __name__=="__main__":
    main(sys.argv)
