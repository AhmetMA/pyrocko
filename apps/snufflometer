#!/usr/bin/env python

'''Effective MiniSEED trace viewer.'''

# Copyright (c) 2009, Sebastian Heimann <sebastian.heimann@zmaw.de>
#
# This file is part of snuffler. For licensing information please see the file 
# COPYING which is included with snuffler.

import os, sys, signal, logging, time
import numpy as num
from optparse import OptionParser
from subprocess import Popen, PIPE


import pyrocko.hamster_pile
import pyrocko.util
import pyrocko.pile_viewer
import pyrocko.slink
import pyrocko.serial_hamster

from PyQt4.QtCore import *
from PyQt4.QtGui import *

logger = logging.getLogger('pyrocko.snufflometer')

class QSynchronizedSlink(pyrocko.serial_hamster.SerialHamster):
    
    def __init__(self, *args, **kwargs ):
        pyrocko.serial_hamster.SerialHamster.__init__(self, *args, **kwargs)
        self.mutex = QMutex()
        self.queue = []
    
    def run(self):
        pass
 
    def got_trace(self, tr):
        self.mutex.lock()
        self.queue.append(tr)
        self.mutex.unlock()
    
    def poll(self):
        self.mutex.lock()
        items = self.queue[:]
        self.queue[:] = []
        self.mutex.unlock()
        return items
    
class QSlinkThread(QThread):
    def __init__(self, *args, **kwargs):
        QThread.__init__(self)
        self.args = args
        self.kwargs = kwargs
        self.slink = None
    
    def get_slink(self):
        return self.slink
    
    def run(self):
        
        while True:
            try:
            
                self.slink = QSynchronizedSlink(*self.args, **self.kwargs)
                self.slink.start()
                while self.slink.sun_is_shining():
                    self.slink.process()
                    
                self.slink.stop()
                break
                
            except pyrocko.serial_hamster.SerialHamsterError, e:
                logger.error(str(e))
                logger.error('Acquistion terminated, restart in 5 s')
                self.slink.stop()
                self.slink.clear_listeners()
                time.sleep(5)
                if not self.slink.sun_is_shining():
                    break
            
            
    def stop(self):
        pass
        
 
class SlinkSnuffler(QApplication):
    
    def __init__(self, *args):
        apply(QApplication.__init__, (self,) + args)
        
        parser = OptionParser()
        parser.add_option('--ntracks', dest='ntracks', default=24)
        parser.add_option('--debug', dest='debug', action='store_true', default=False)
        parser.add_option('--port', dest='port', default='0')
        parser.add_option('--baudrate', dest='baudrate', default='9600')
        parser.add_option('--timeout', dest='timeout', default='5')
        parser.add_option('--opengl', dest='opengl', action='store_true', default=False)
        
        options, args = parser.parse_args(list(args[0][1:]))
        
        if options.debug:
            pyrocko.util.setup_logging('snuffler', 'debug')
        else:
            pyrocko.util.setup_logging('snuffler', 'warning')
        
        self.pile = pyrocko.hamster_pile.HamsterPile()
        
        self.win = QMainWindow()
        self._dockwidgets = []
        
        self.pile_viewer = pyrocko.pile_viewer.PileViewer(
                    self.pile, 
                    ntracks_shown_max=options.ntracks,
                    use_opengl=options.opengl, add_panel_hook=self.add_panel)
                    
        self.win.setWindowTitle( "Snuffslink" )        
        self.win.setCentralWidget( self.pile_viewer )
        self.add_panel('Main Controls', self.pile_viewer.controls())

        self.win.show()

        sb = self.win.statusBar()
        sb.clearMessage()
        sb.showMessage('Welcome to Snuffler! Click and drag to zoom and pan. Doubleclick to pick. Right-click for Menu. <space> to step forward. <b> to step backward. <q> to close.')

        self.connect(self, SIGNAL("lastWindowClosed()"), self.myquit)
        signal.signal(signal.SIGINT, self.myquit)
        
      #  source = Popen(['./test_datasource.py'], stdout=PIPE)

        self.slt = QSlinkThread(
            port=options.port, 
            baudrate=int(options.baudrate), 
            timeout=float(options.timeout), 
       #     in_file=source.stdout
           )
        
        self.timer = QTimer( self )
        self.connect( self.timer, SIGNAL("timeout()"), self.periodical ) 
        self.timer.setInterval(1000)
        self.timer.start()
        
        self.traces = {}
        self.traces_to_files = {}
        
        self.slt.start()
    
    def add_panel(self, name, panel):
        dockwidget = QDockWidget(name)
        dockwidget.setWidget(panel)
        self.win.addDockWidget(Qt.BottomDockWidgetArea, dockwidget)
        
        if self._dockwidgets:
            self.win.tabifyDockWidget(self._dockwidgets[-1], dockwidget)
        
        self._dockwidgets.append(dockwidget)
        dockwidget.raise_()
        
        def delete_panel():
            self.win.removeDockWidget(dockwidget)
            self._dockwidgets.remove(dockwidget)
        
        return delete_panel
    
    def periodical(self):
        slink = self.slt.get_slink()
        if slink and slink.sun_is_shining():
            traces = self.slt.get_slink().poll()
            if traces:
                for tr in traces:
                    self.pile.insert_trace(tr)
            
                self.pile_viewer.pile_overview.update()
        
    def myquit(self, *args):
        self.pile.fixate_all()
        self.slt.stop()
        self.quit()
    
def main(args):
    
    app = SlinkSnuffler(args)
    app.exec_()
    
    if pyrocko.pile_viewer.Global.sacflag: pyrocko.pile_viewer.sac_exec()
    sys.exit()

if __name__=="__main__":
    main(sys.argv)
